/*
▶ 엔진이란?
- 라이브러리 집합체 + 에디터(Tool) 추가한것이 엔진의 정의

- 엔진 왜 쓸까?

- 개발 기간 단축(그래픽)
ㄴ 수학 + 물리 종결 -> 3D에서 많이 정체가 되기 시작한다.
다이렉트 + 불칸은 해야한다.

- 그래픽스 프로그래밍
- 양대 산맥
ㄴ DX VS OpenGL
이제 떠오르는 불칸(레이 트레이싱에 특화)

- DX와 OpenGL의 차이점?
ㄴ 좌표계 (마야 / 맥스까지도 전부 영향을 받는다.)
	ㄴ 왼손 / 오른손
		ㄴ 차이는 Z축의 진행 방향과 X축의 방향
DX의 장점 : Low한 레벨에서 최적화가 좋다.
DX의 단점 : 윈도우에 종속된다.
DX는 윈도우에 종속되기 때문에 엔진에서 OpenGL까지 같이 지원한다.
OpenGL은 플랫폼에 종속되지 않기 때문에

- 왼손 / 오른손 좌표계?
ㄴ 기본 베이스는 DX -> 언리얼
	유니티 -> OpenGL
ㄴ 그리고 또다른 차이점은 월드 좌표에 차이가 발생한다.
	ㄴ SRT / TRS (Scale, Rotation, Transform)

- DX -> 윈도우즈 (CPU가 필요하지 않고 GPU만 쓰는 경우도 있다)
ㄴ DX9 / 10 / 11 / 12
ㄴ 9- > 11
ㄴ 9 다음부터는 안티 얼라이싱을 안쓰고 쉐이더계산이 파이프라인에 들어가 9부터 공부
ㄴ Tessellation : 선명하지만 연산이 많다

- OpenGL -> 플랫폼 X (최소한의 CPU가 필요 ex) 엘리베이터)

▶ 렌더링 파이프라인
그래픽 공정 과정
- 파이프라인에는 기본적으로 다양한 종류가 있다.
ㄴ built-in, SRP, URP, HDRP
built-in : 커스텀해서 쓰고 싶을 때 사용
SRP : 다이렉트나 OpenGL의 파이프라인 코드기반
URP : 유니티 또는 언리얼에서 재정의한 파이프라인
HDRP : High Dynamic Rendering Pipeline 쉐이더(광원, 음영, VFX 파티클시스템) 전용 파이프라인
이펙트 : 이미지 기반 처리, CPU처리
파티클 : 입자 기반 처리, Vertex들의 집합, GPU 처리

- 파이프라인마다 세부적인 내용에는 차이가 있지만 큰 틀은 벗어나지 않는다.
ㄴ Fixed PipeLine(정적) - 프로그래머가 관여 X, DX9 / Progammable PipeLine(동적) - 프로그래머가 관여 O, DX 11

1. 로컬 스페이스
ㄴ 디자이너의 영역
ㄴ 오브젝트 좌표계

2. 월드 스페이스
ㄴ 가상의 공간을 만들고 적용을 하기전 단계(★★★★★SRT★★★★★)

3. 뷰 스페이스
ㄴ 카메라 공간이라고 할 수 있다.

4. 백 스페이스 컬링(후면 추려내기)
ㄴ tearing 현상 발생 원인
ㄴ 뒷면을 그리지 않는다.
ㄴ DX나 엔진에서 알아서 해준다.

★★★★★
5. 라이트
ㄴ 너희의 무덤... -> 최적화에 핵심중 1개
ㄴ 크게 정반사(Specular)와 ex) 후레쉬 / 난반사(Diffuse) ex) 햇빛의 그림자
ㄴ 종류 : Point(점) / Directional(방향성) / Spot(점적) ex) 가로등 / Ambient(주변광)
	ㄴ 재질 : Ambient(주변) / Diffuse(확산) / Specular(반사) / Emissive(방출)

6. 클리핑
ㄴ 카메라 각도 외의 물체들을 렌더링하지 않는다.

7. 프로젝션(투영)
ㄴ 3D -> 2D로 변환하는 과정
ㄴ 크게 2가지 기법이 존재한다.

1. Perspective (원근 투영)
ㄴ 3D
ㄴ 원근감을 표현하겠다. 거리에 따라 스케일 변화

2. Orthographic ( 직교 투영)
ㄴ 2D
ㄴ 원근감 없이 수직 위에서 내려다 보듯이 투영한다.

8. 뷰포트
ㄴ 모니터 화면에 올린다.

9. 레스터라이즈(픽셀 보간)
ㄴ 폴리곤 -> 픽셀로
ㄴ 스크린 좌표로 정점들을 변환하면 폴리곤 정보를 가지게 된다.
ㄴ 래스터라이즈는 각각의 폴리곤을 출력하는데 필요한 픽셀컬러 값을 계산하는 과정
ㄴ 기본적으로 컴퓨터가 처리한다.
*/
#pragma region 언리얼 엔진
/*
▶ 언리얼 엔진

- 언리얼 엔진의 파트는?
ㄴ 아트 : 캐릭터, 배경, 액터 등을 제작하고 배치 + 레벨의 비주얼 작업을 하는 사람들
ㄴ 프로그래밍 : 이외 나머지에 대한 처리를 구현하는 사람들
	ㄴ 규모가 커진다면 여기서도 세분화가 많이 되고 규모가 작다면 전부다 우리 몫

- 기본적으로 엔진을 잘 다룬다는건 아트 + 프로그래밍 영역을 모두 소화할 수 있다는 얘기
	ㄴ 서로 상호보완적인 관계가 있지만 근본적으로 플밍을 잘해야 한다.
		ㄴ TA


- 새로운 지식 + 반복 숙달 (과제) + 샘플 게임

- 앤진을 잘 쓰고 싶으면 구조 파악이 최우선
ㄴ 정의된 노드가 나오면 반드시 한번정도 분석을 실행한다.

▷ 좌표축

- 언리얼 엔진은 기존의 포맷과 좌표축이 다르다.

- 뷰포트 좌표계는 일반적으로 좌하단을 기준으로 렌더링한다.
ㄴ 엔진에서도 API가 들어가 있기 때문에 2D / 3D 구분없이 UI를 표현할 때는 API좌표계를 사용한다.

- DX3D (왼손) / OpenGL (오른손)
ㄴ DX3D : 결합 순서 (SRT)
ㄴ OpenGL : 결합 순서 (TRS)

★ 기술 면접 다발 지역 ★
※ 당장 공부해야 할것 -> 포폴 전까지

1. 행렬 (정방 행렬)
ㄴ 3 X 3
ㄴ 4 X 4
ㄴ 역행렬
	ㄴ 간단한 값의 역행렬은 행렬과 단위 행렬이라고 할 수 있지만
	   복잡한 행렬은 역행렬을 가진다. (거친다. -> 연산량 줄일때)
	ㄴ 왠만하면 필요 없을것 같지만 역행렬이 있기 때문에 로컬 -> 월드 -> 뷰 -> 모니터에서 다시 역순으로 돌아갈 수 있는것

2. 벡터
ㄴ 크게 3가지만 준비하면 된다.
	ㄴ 덧 / 뺄 / 곱
		ㄴ 곱 : 외적 / 내적

- 위에 같은 개념을 기반으로 언리얼 엔진은 모든 렌더링을 거칠때 반드시 셰이더를 거치고 렌더링이 된다.
	(버텍스 자체가 CPU 처리를 해버리면 굉장히 코드스를 요구하기 때문)

- 프로그래밍 차원에서는 CPU -> GPU -> 메모리를 최적화
- 언리얼에서는 GPU -> CPU -> 메모리

- 언리얼 엔진

- 장점
ㄴ 멀티 플랫폼 지원
ㄴ 통합 개발 환경 지원
ㄴ 통합 에셋 관리 시스템 지원
ㄴ 스크립팅 시스템 지원 (런 / 에디터)
ㄴ 파티클 시스템 지원
ㄴ 2D 시스템 지원 (타일 맵, 페이어 2D)
ㄴ 렌더링 시스템 지원
ㄴ 셰이더 시스템 지원
ㄴ 사운드 시스템 지원
ㄴ 물리 시스템 지원
ㄴ 지형 시스템 지원
ㄴ 프로파일링 시스템 지원
ㄴ 마켓 플레이스 지원
ㄴ 애니메이션 시스템 지원 (레거시 / 블.스)

- 단점
ㄴ 무겁다.
ㄴ 입문 난이도가 높다.
ㄴ 개발 기간이 평균이상으로 책정되야 한다.
ㄴ 원활한 개발을 위해서는 숙달된 프로그래머가 반드시 포함되어야 한다.
ㄴ 회사 풀이 적다.
ㄴ 엔진을 활용한 게임 개발이 즐겁지 않다.

-------------------------------
▶ 컴포넌트 프로그래밍?

- 상속 기반 프로그래밍에서의 단점을 극복하기 위해 나온 프로그래밍 방식
ㄴ 물체를 1개 이상 정의하고 그 물체의 기능을 확장해 나가는 식으로 작업을 하는 개념
ㄴ 컴포넌트 기반 프로그래밍은 기본적으로 덕 타이핑 개념으로 이해하면 될것 같다.

◈ 덕 타이핑(Duck Typing)
ㄴ 동적 타이핑의 한 종류
ㄴ 객체의 변수 및 메서드의 집합이 객체의 타입을 결정한다는 뜻

- 장점
ㄴ 유연하다.
ㄴ 유지보수가 아주 훌륭하다.
ㄴ 설계단계에서 비교적 수월하다.


- 단점
ㄴ 컴포넌트 기반으로 동작을 하기 때문에 이를 엮어줄 기능 / 로직이 반드시 필요하다.
ㄴ 엮어줄 기능 / 로직이 필요하기 때문에 필연적으로 퍼포먼스 측면에서는 떨어진다.

▷ 언리얼 엔진에서의 컴포넌트 기반 프로그래밍

- 언리얼 엔진인 컨테이너에 해당하는 게임 객체 (Actor)와 EngineCore 클래스를 통해 컴포넌트 방식을 제어하는 매커니즘을 구현할 수 있다.

- 커스텀 스크립트 컴포넌트는 반드시 Engine / EngineCore / CoreMinimal 셋중 1개를 반드시 받아야 언리얼 객체에서 지원하는 기능을 활용할 수 있다.

*/
#pragma endregion

#pragma region 오늘의 언리얼 엔진
/*
▶ 검색

Light

-Light : 빼고 검색

+Light : 정확하게 검색

"Light" : 타입 검색

▶ 용어

유니티 : 오브젝트, 컴포넌트
언리얼 : 액터 / 폰 / 컴포넌트
ㄴ 액터는 이동 / 회전 / 스케일 같은 트랜스폼만을 가진 오브젝트

● 머티리얼 (재질)

- Surface에 적용할 수 있는 미리 빌드된 비주얼 이펙트

- 머티리얼은 텍스처 / 색상 / 거칠기 / 빛 등 모든 Surface 디테일을 감싸는 역할을 한다.

● 전역 조명

- 

● Z fighting : 서로 렌더링되려고 순서가 계속 바뀌어서 깜빡이는 현상
우선순위를 두거나(Depth Buffer) 소수를 Int로 바꿔서 해결(스텐실 버퍼)

● 언리얼 vs 유니티

- Roughness(마야, 블렌더)
ㄴ 거칠기 (1에 가까워질수록 거칠어 진다.)

- Smoothness(맥스)
ㄴ 매끄러운 정도(1에 가까워질수록 표면이 매끄러워 진다.)

★★★★★★★★★★ -> 충돌
▶ 메시

- 3D 모델을 구성하는데 가장 중요한 개념

1. 정점 (Vertex)

- 하나의 점 -> 3D의 기본 단위
ㄴ 2D에서 말하는 점과는 완벽한 차이가 존재하며 2D의 포인트 같은 경우는 X, Y의 좌표값만 들고 있지만 3D의 정점은 위치 좌표 / 법선 / 색상 / UV에 필수 정보를
모두 가지고 있다.

2. 다각형 (Polygon)

- 최소한의 면 단위를 말하며 흔히 삼각형에 비유된다.

- 정점이 있고 선과 선들이 모여 최소한의 면을 이룬다.
	ㄴ 삼각형

- 버텍스 3개가 모이면 가장 작은 단위인 면 단위를 이룰 수 있고 이걸 폴리곤이라고 한다.

3. 메시 (Mesh)

- 메시는 폴리곤이 모여 만들어진 3D공간상에 물체

	ㆍ Static Mesh

	- 일반적으로 사용하는 메시외에도 Static Mesh라는 객체가 있다.
	ㄴ Static은 말 그대로 정적이라고 이해하면 좋을것 같다.

※ 3D / 그래픽스 파트에서는 특별한 경우를 제외하고는 전부 메시를 통해 렌더링을 진행한다.
ㄴ 복셀 / 옥테인
Vertex에는 Vertex Shader
Vertex가 이루는 면에는 지오메트릭 셰이더가 들어간다.
ㄴ Vertex를 깍아준다.

테셀리이션 기법(셰이더)
ㄴ 헐 + 구메인(영역셰이딩)
셰이더 기법 읽어보기(고러드 퐁 플랫 구닥다리)

-> 2D -> 픽셀 셰이더

ㆍ 언리얼의 지오매트리는 면 중에 버텍스를 다룬다. -> BSP 렌더링 기법을 사용한다는 얘기

◈ BSP : 이진 공간 분할법
ㄴ 재귀적으로 공간을 평면 상의 블록 집합으로 분할하는 기법을 의미한다.
	ㄴ 분할 과정에서 BSP 트리라 불리는 트리 구조가 형성이 된다.

▶ UV

- 텍스처 매핑에 사용되는 좌표계
ㄴ 백분율로 사용 (0.0 ~ 1.0)

- 하나의 면에 이미지를 붙인다고 가정을 한다면...
	ㄴ 이 면은 클수도 있고 작을 수도 있다. (전체 면을 100, 100)
	ㄴ 그럼 이 면에다가 이미지를 붙일건데 나는 50, 50을 붙일 예정
	ㄴ 붙이는 작업도 어떻게 붙일건지에 대한 옵션값이 존재한다.
	ㄴ EX : 확대 진행? / 축소 진행?
		ㄴ 버텍스 -> 포지션 + UV 좌표계에 대한 정보가 기입되어 있다.
			ㄴ 포지션 : 3D / UV : 2D
				ㄴ 3D 좌표계로 변환 -> 3D 텍스처 / 큐브맵
- 나나이트 : 영화에서 사용하는 마이크로 폴리곤 수준의 메시를 지오메트리 가상화를 통해 실시간 렌더링하는 기술
화면에 보이는 것만 렌더링, 전체 장면을 담은 GPU 씬을 비디오 메모리에 저장 이전 프레임과 변경된 부분에 대해서만 보수하면서 업데이트
모든 버텍스 / 인덱스 데이터를 하나의 큰 리소스에 보관
클러스터 단위의 래스터라이저 큰 삼각형의 경우에는 HW 래스터라이저
루멘 : 실시간으로 사용 가능한 다이내믹 글로벌 일루미네이션
*/
#pragma endregion