/*
▶ 엔진이란?
- 라이브러리 집합체 + 에디터(Tool) 추가한것이 엔진의 정의

- 엔진 왜 쓸까?

- 개발 기간 단축(그래픽)
ㄴ 수학 + 물리 종결 -> 3D에서 많이 정체가 되기 시작한다.
다이렉트 + 불칸은 해야한다.

- 그래픽스 프로그래밍
- 양대 산맥
ㄴ DX VS OpenGL
이제 떠오르는 불칸(레이 트레이싱에 특화)

- DX와 OpenGL의 차이점?
ㄴ 좌표계 (마야 / 맥스까지도 전부 영향을 받는다.)
	ㄴ 왼손 / 오른손
		ㄴ 차이는 Z축의 진행 방향과 X축의 방향
DX의 장점 : Low한 레벨에서 최적화가 좋다.
DX의 단점 : 윈도우에 종속된다.
DX는 윈도우에 종속되기 때문에 엔진에서 OpenGL까지 같이 지원한다.
OpenGL은 플랫폼에 종속되지 않기 때문에

- 왼손 / 오른손 좌표계?
ㄴ 기본 베이스는 DX -> 언리얼
	유니티 -> OpenGL
ㄴ 그리고 또다른 차이점은 월드 좌표에 차이가 발생한다.
	ㄴ SRT / TRS (Scale, Rotation, Transform)

- DX -> 윈도우즈 (CPU가 필요하지 않고 GPU만 쓰는 경우도 있다)
ㄴ DX9 / 10 / 11 / 12
ㄴ 9- > 11
ㄴ 9 다음부터는 안티 얼라이싱을 안쓰고 쉐이더계산이 파이프라인에 들어가 9부터 공부
ㄴ Tessellation : 선명하지만 연산이 많다

- OpenGL -> 플랫폼 X (최소한의 CPU가 필요 ex) 엘리베이터)

▶ 렌더링 파이프라인
그래픽 공정 과정
- 파이프라인에는 기본적으로 다양한 종류가 있다.
ㄴ built-in, SRP, URP, HDRP
built-in : 커스텀해서 쓰고 싶을 때 사용
SRP : 다이렉트나 OpenGL의 파이프라인 코드기반
URP : 유니티 또는 언리얼에서 재정의한 파이프라인
HDRP : High Dynamic Rendering Pipeline 쉐이더(광원, 음영, VFX 파티클시스템) 전용 파이프라인
이펙트 : 이미지 기반 처리, CPU처리
파티클 : 입자 기반 처리, Vertex들의 집합, GPU 처리

- 파이프라인마다 세부적인 내용에는 차이가 있지만 큰 틀은 벗어나지 않는다.
ㄴ Fixed PipeLine(정적) - 프로그래머가 관여 X, DX9 / Progammable PipeLine(동적) - 프로그래머가 관여 O, DX 11

1. 로컬 스페이스
ㄴ 디자이너의 영역
ㄴ 오브젝트 좌표계

2. 월드 스페이스
ㄴ 가상의 공간을 만들고 적용을 하기전 단계(★★★★★SRT★★★★★)

3. 뷰 스페이스
ㄴ 카메라 공간이라고 할 수 있다.

4. 백 스페이스 컬링(후면 추려내기)
ㄴ tearing 현상 발생 원인
ㄴ 뒷면을 그리지 않는다.
ㄴ DX나 엔진에서 알아서 해준다.

★★★★★
5. 라이트
ㄴ 너희의 무덤... -> 최적화에 핵심중 1개
ㄴ 크게 정반사(Specular)와 ex) 후레쉬 / 난반사(Diffuse) ex) 햇빛의 그림자
ㄴ 종류 : Point(점) / Directional(방향성) / Spot(점적) ex) 가로등 / Ambient(주변광)
	ㄴ 재질 : Ambient(주변) / Diffuse(확산) / Specular(반사) / Emissive(방출)

6. 클리핑
ㄴ 카메라 각도 외의 물체들을 렌더링하지 않는다.

7. 프로젝션(투영)
ㄴ 3D -> 2D로 변환하는 과정
ㄴ 크게 2가지 기법이 존재한다.

1. Perspective (원근 투영)
ㄴ 3D
ㄴ 원근감을 표현하겠다. 거리에 따라 스케일 변화

2. Orthographic ( 직교 투영)
ㄴ 2D
ㄴ 원근감 없이 수직 위에서 내려다 보듯이 투영한다.

8. 뷰포트
ㄴ 모니터 화면에 올린다.

9. 레스터라이즈(픽셀 보간)
ㄴ 폴리곤 -> 픽셀로
ㄴ 스크린 좌표로 정점들을 변환하면 폴리곤 정보를 가지게 된다.
ㄴ 래스터라이즈는 각각의 폴리곤을 출력하는데 필요한 픽셀컬러 값을 계산하는 과정
ㄴ 기본적으로 컴퓨터가 처리한다.
*/
#pragma region 언리얼 엔진
/*
▶ 언리얼 엔진

- 언리얼 엔진의 파트는?
ㄴ 아트 : 캐릭터, 배경, 액터 등을 제작하고 배치 + 레벨의 비주얼 작업을 하는 사람들
ㄴ 프로그래밍 : 이외 나머지에 대한 처리를 구현하는 사람들
	ㄴ 규모가 커진다면 여기서도 세분화가 많이 되고 규모가 작다면 전부다 우리 몫

- 기본적으로 엔진을 잘 다룬다는건 아트 + 프로그래밍 영역을 모두 소화할 수 있다는 얘기
	ㄴ 서로 상호보완적인 관계가 있지만 근본적으로 플밍을 잘해야 한다.
		ㄴ TA


- 새로운 지식 + 반복 숙달 (과제) + 샘플 게임

- 앤진을 잘 쓰고 싶으면 구조 파악이 최우선
ㄴ 정의된 노드가 나오면 반드시 한번정도 분석을 실행한다.

▷ 좌표축

- 언리얼 엔진은 기존의 포맷과 좌표축이 다르다.

- 뷰포트 좌표계는 일반적으로 좌하단을 기준으로 렌더링한다.
ㄴ 엔진에서도 API가 들어가 있기 때문에 2D / 3D 구분없이 UI를 표현할 때는 API좌표계를 사용한다.

- DX3D (왼손) / OpenGL (오른손)
ㄴ DX3D : 결합 순서 (SRT)
ㄴ OpenGL : 결합 순서 (TRS)

★ 기술 면접 다발 지역 ★
※ 당장 공부해야 할것 -> 포폴 전까지

1. 행렬 (정방 행렬)
ㄴ 3 X 3
ㄴ 4 X 4
ㄴ 역행렬
	ㄴ 간단한 값의 역행렬은 행렬과 단위 행렬이라고 할 수 있지만
	   복잡한 행렬은 역행렬을 가진다. (거친다. -> 연산량 줄일때)
	ㄴ 왠만하면 필요 없을것 같지만 역행렬이 있기 때문에 로컬 -> 월드 -> 뷰 -> 모니터에서 다시 역순으로 돌아갈 수 있는것

2. 벡터
ㄴ 크게 3가지만 준비하면 된다.
	ㄴ 덧 / 뺄 / 곱
		ㄴ 곱 : 외적 / 내적

- 위에 같은 개념을 기반으로 언리얼 엔진은 모든 렌더링을 거칠때 반드시 셰이더를 거치고 렌더링이 된다.
	(버텍스 자체가 CPU 처리를 해버리면 굉장히 코드스를 요구하기 때문)

- 프로그래밍 차원에서는 CPU -> GPU -> 메모리를 최적화
- 언리얼에서는 GPU -> CPU -> 메모리

- 언리얼 엔진

- 장점
ㄴ 멀티 플랫폼 지원
ㄴ 통합 개발 환경 지원
ㄴ 통합 에셋 관리 시스템 지원
ㄴ 스크립팅 시스템 지원 (런 / 에디터)
ㄴ 파티클 시스템 지원
ㄴ 2D 시스템 지원 (타일 맵, 페이어 2D)
ㄴ 렌더링 시스템 지원
ㄴ 셰이더 시스템 지원
ㄴ 사운드 시스템 지원
ㄴ 물리 시스템 지원
ㄴ 지형 시스템 지원
ㄴ 프로파일링 시스템 지원
ㄴ 마켓 플레이스 지원
ㄴ 애니메이션 시스템 지원 (레거시 / 블.스)

- 단점
ㄴ 무겁다.
ㄴ 입문 난이도가 높다.
ㄴ 개발 기간이 평균이상으로 책정되야 한다.
ㄴ 원활한 개발을 위해서는 숙달된 프로그래머가 반드시 포함되어야 한다.
ㄴ 회사 풀이 적다.
ㄴ 엔진을 활용한 게임 개발이 즐겁지 않다.

-------------------------------
▶ 컴포넌트 프로그래밍?

- 상속 기반 프로그래밍에서의 단점을 극복하기 위해 나온 프로그래밍 방식
ㄴ 물체를 1개 이상 정의하고 그 물체의 기능을 확장해 나가는 식으로 작업을 하는 개념
ㄴ 컴포넌트 기반 프로그래밍은 기본적으로 덕 타이핑 개념으로 이해하면 될것 같다.

◈ 덕 타이핑(Duck Typing)
ㄴ 동적 타이핑의 한 종류
ㄴ 객체의 변수 및 메서드의 집합이 객체의 타입을 결정한다는 뜻

- 장점
ㄴ 유연하다.
ㄴ 유지보수가 아주 훌륭하다.
ㄴ 설계단계에서 비교적 수월하다.


- 단점
ㄴ 컴포넌트 기반으로 동작을 하기 때문에 이를 엮어줄 기능 / 로직이 반드시 필요하다.
ㄴ 엮어줄 기능 / 로직이 필요하기 때문에 필연적으로 퍼포먼스 측면에서는 떨어진다.

▷ 언리얼 엔진에서의 컴포넌트 기반 프로그래밍

- 언리얼 엔진인 컨테이너에 해당하는 게임 객체 (Actor)와 EngineCore 클래스를 통해 컴포넌트 방식을 제어하는 매커니즘을 구현할 수 있다.

- 커스텀 스크립트 컴포넌트는 반드시 Engine / EngineCore / CoreMinimal 셋중 1개를 반드시 받아야 언리얼 객체에서 지원하는 기능을 활용할 수 있다.

*/
#pragma endregion